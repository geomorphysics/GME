"""
---------------------------------------------------------------------

Visualization.

Provides classes to generate a range of graphics for GME visualization.
A base class extends :class:`gmplib.plot_utils.GraphingBase <plot_utils.GraphingBase>`
provided by :mod:`GMPLib`; the other classes build on this.
Each is tailored to a particular category of GME problem,
such as single ray tracing or for tracking knickpoints.

---------------------------------------------------------------------

Requires Python packages/modules:
  -  :mod:`gmplib.plot_utils <plot_utils>`
  -  :mod:`numpy`
  -  :mod:`sympy`
  -  :mod:`matplotlib.pyplot`
  -  :mod:`matplotlib.ticker`
  -  :mod:`matplotlib.patches`
  -  :mod:`mpl_toolkits.axes_grid1`

Imports symbols from :mod:`.symbols` module.

---------------------------------------------------------------------

"""

# pylint: disable=locally-disabled, multiple-statements, fixme, line-too-long, invalid-name

# Numpy
import numpy as np

# Scipy utils
from scipy.linalg import eig, eigh, det, norm
from scipy.optimize import root_scalar

# SymPy
from sympy import Eq, factor, N, Abs, lambdify, Rational, Matrix, poly, \
                    simplify, diff, sign, sin, tan, deg, solve, sqrt, rad, numer, denom, im, re, \
                    atan, oo

# GMPLib
from gmplib.utils import e2d, omitdict, round as gmround, convert

# GME
from gme.symbols import varphi_r, xiv, xiv_0, pz_min, varphi, px, pz, px_min, \
                        H, beta_max, Lc, gstarhat, xih_0, mu, eta, pxhat, pzhat, rxhat, rzhat, Ci
from gme.equations import px_value
from gme.plot import Graphing

# MatPlotLib
import matplotlib.pyplot as plt
from matplotlib import ticker
from matplotlib.ticker import FormatStrFormatter
import matplotlib.patches as mpatches
from matplotlib.patches import Patch, FancyArrow, FancyArrowPatch, Arrow, Rectangle, Circle, RegularPolygon,\
                                ArrowStyle, ConnectionPatch, Arc
from matplotlib.spines import Spine
from matplotlib.legend_handler import HandlerPatch
from matplotlib import cm
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

import warnings
warnings.filterwarnings("ignore")

__all__ = ['OneRayPlots']


class OneRayPlots(Graphing):
    """
    Subclasses :class:`gme.plot.Graphing <plot.Graphing>`.
    """

    def profile_ray( self, gmes, gmeq, sub, name, fig_size=None, dpi=None,
                        y_limits=None, eta_label_xy=None, n_points=101, aspect=None,
                        do_direct=True, do_schematic=False,
                        do_simple=False, do_t_sampling=True, do_etaxi_label=True,
                        do_pub_label=False, pub_label='', pub_label_xy=[0.15,0.50] ):
        r"""
        Plot a set of erosion rays for a time-invariant topographic profile solution of Hamilton's equations.

        Hamilton's equations are integrated once (from the left boundary to the divide)
        and a time-invariant profile is constructed by repeating
        the ray trajectory, with a suitable truncation and vertical initial offset, multiple times at the left boundary:
        the set of end of truncated rays constitutes the 'steady-state' topographic profile.
        The point of truncation of each trajectory corresponds to the effective time lag imposed by the choice of vertical initial
        offset (which is controlled by the vertical slip rate).

        Visualization of this profile includes: (i) plotting a subsampling of the terminated points of the ray truncations;
        (ii) plotting a continuous curve generated by integrating the surface gradient implied by the erosion-front normal
        covector values :math:`\mathbf{\widetilde{p}}` values generated by solving Hamilton's equations.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            sub (dict): dictionary of model parameter values to be used for equation substitutions
            do_direct (bool): plot directly integrated ray trajectory (from :math:`\mathbf{\widetilde{p}}` values) as a solid curve
            do_schematic (bool):
                optionally plot in more schematic form for expository purposes?
            do_simple (bool): optionally simplify?

        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)
        axes = plt.gca()

        t_array  = gmes.t_array
        rx_array = gmes.rx_array
        # rz_array = gmes.rz_array
        # v_array = n.sqrt(gmes.rdotx_array**2 + gmes.rdotz_array**2)

        if do_t_sampling:
            t_begin, t_end = t_array[0], t_array[-1]
            t_rsmpld_array = np.linspace(t_begin, t_end, n_points)
        else:
            x_rsmpld_array = np.linspace(rx_array[0], rx_array[-1], n_points)
            t_rsmpld_array = gmes.t_interp_x(x_rsmpld_array)
        rx_rsmpld_array = gmes.rx_interp_t(t_rsmpld_array)
        rz_rsmpld_array = gmes.rz_interp_t(t_rsmpld_array)
        v_rsmpld_array = np.sqrt(gmes.rdotx_interp_t(t_rsmpld_array)**2
                                + gmes.rdotz_interp_t(t_rsmpld_array)**2)

        # Plot arrow-annotated rays
        self.draw_rays_with_arrows_simple( axes, sub,
                                          t_rsmpld_array, rx_rsmpld_array, rz_rsmpld_array, v_rsmpld_array,
                                          n_rays=1, n_t=None,
                                          ls='-', sf=1, do_one_ray=True, color='0.5' )

        axes.set_aspect(aspect if aspect is not None else 1)
        plt.grid(True, ls=':')
        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=13)
        plt.ylabel(r'Elevation, $z/L_{\mathrm{c}}$  [-]', fontsize=13)
        if eta_label_xy is None:
            eta_label_xy = (0.92,0.15)
        if not do_schematic and not do_simple:
            if do_etaxi_label:
                plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
                # plt.text(*eta_label_xy, rf'$\eta={gmeq.eta}$',
                         transform=axes.transAxes,
                         horizontalalignment='center', verticalalignment='center',
                         fontsize=13, color='k')
            if do_pub_label:
                plt.text(*pub_label_xy, pub_label,
                         transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=16, color='k')
        if y_limits is not None:
            plt.ylim(*y_limits)

    def profile_h_rays( self, gmes, gmeq, sub, name, fig_size=None, dpi=None,
                        x_limits=None, y_limits=None, n_points=101,
                        do_direct=True, n_rays=4, profile_subsetting=5,
                        do_schematic=False, do_legend=True, do_profile_points=True, do_fault_bdry=False,
                        do_one_ray=False, do_t_sampling=True, do_etaxi_label=True,
                        do_pub_label=False, pub_label='', pub_label_xy=[0.93,0.33], eta_label_xy=[0.5,0.8] ):
        r"""
        Plot a set of erosion rays for a time-invariant topographic profile solution of Hamilton's equations.

        Hamilton's equations are integrated once (from the left boundary to the divide)
        and a time-invariant profile is constructed by repeating
        the ray trajectory, with a suitable truncation and vertical initial offset, multiple times at the left boundary:
        the set of end of truncated rays constitutes the 'steady-state' topographic profile.
        The point of truncation of each trajectory corresponds to the effective time lag imposed by the choice of vertical initial
        offset (which is controlled by the vertical slip rate).

        Visualization of this profile includes: (i) plotting a subsampling of the terminated points of the ray truncations;
        (ii) plotting a continuous curve generated by integrating the surface gradient implied by the erosion-front normal
        covector values :math:`\mathbf{\widetilde{p}}` values generated by solving Hamilton's equations.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            sub (dict): dictionary of model parameter values to be used for equation substitutions
            do_direct (bool): plot directly integrated ray trajectory (from :math:`\mathbf{\widetilde{p}}` values) as a solid curve
            ray_subsetting (int): optional ray subsampling rate (typically far more rays are computed than should be plotted)
            do_schematic (bool):
                optionally plot in more schematic form for expository purposes?
            do_simple (bool): optionally simplify?

        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)
        axes = plt.gca()

        t_array  = gmes.t_array #[::ray_subsetting]
        rx_array = gmes.rx_array #[::ray_subsetting]
        rz_array = gmes.rz_array #[::ray_subsetting]

        if do_t_sampling:
            t_begin, t_end = t_array[0], t_array[-1]
            t_rsmpld_array = np.linspace(t_begin, t_end, n_points)
        else:
            x_rsmpld_array = np.linspace(rx_array[0], rx_array[-1], n_points)
            t_rsmpld_array = gmes.t_interp_x(x_rsmpld_array)
        rx_rsmpld_array = gmes.rx_interp_t(t_rsmpld_array)
        rz_rsmpld_array = gmes.rz_interp_t(t_rsmpld_array)

        # Plot arrow-annotated rays
        self.draw_rays_with_arrows_simple( axes, sub,
                                           t_rsmpld_array, rx_rsmpld_array, rz_rsmpld_array,
                                           n_rays=n_rays, n_t=None,
                                           ls='-' if do_schematic else '-',
                                           sf=0.5 if do_schematic else 1, do_one_ray=do_one_ray )

        if do_schematic:
            # For schematic fig, also plot mirror-image topo profile on opposite side of drainage divide
            self.draw_rays_with_arrows_simple( axes, sub,
                                               t_rsmpld_array, 2-rx_rsmpld_array, rz_rsmpld_array,
                                               n_rays=n_rays, n_t=None,
                                               ls='-' if do_schematic else '-',
                                               sf=0.5 if do_schematic else 1, do_labels=False )

        # # Markers = topo profile from ray terminations
        # if not do_schematic and not do_one_ray:
        #     plt.plot( gmes.x_array[::profile_subsetting], gmes.h_array[::profile_subsetting],
        #                 'k'+('s' if do_profile_points else '-'),
        #                 ms=3, label=r'$T(\mathbf{r})$ from rays $\mathbf{r}(t)$' )

        # Solid line = topo profile from direct integration of gradient array
        if (do_direct or do_schematic) and not do_one_ray:
            plt.plot(gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0]), 'k',
                     label='$T(\mathbf{r})$' if do_schematic else ('$T(\mathbf{r})$') )
            if do_schematic:
                plt.plot(  gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0])+0.26, '0.75', lw=1, ls='--')
                plt.plot(  gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0])+0.13, '0.5', lw=1, ls='--')
                plt.plot(2-gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0]), 'k')
                plt.plot(2-gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0])+0.13, '0.5', lw=1, ls='--')
                plt.plot(2-gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0])+0.26, '0.75', lw=1, ls='--')

        axes.set_aspect(1)
        plt.grid(True, ls=':')
        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=13 if do_schematic else 16)
        plt.ylabel(r'Elevation, $z/L_{\mathrm{c}}$  [-]', fontsize=13 if do_schematic else 16)
        if not do_schematic and not do_one_ray and do_legend:
            plt.legend(loc='upper right' if do_schematic else (0.065,0.45),
                       fontsize=9 if do_schematic else 11,
                       framealpha=0.95)
        if not do_schematic:
            if do_etaxi_label:
                plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
                         transform=axes.transAxes,
                         horizontalalignment='center', verticalalignment='center',
                         fontsize=16, color='k')
            if do_pub_label:
                plt.text(*pub_label_xy, pub_label,
                         transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=16, color='k')
        if x_limits is not None:
            plt.xlim(*x_limits)
        if y_limits is not None:
            plt.ylim(*y_limits)

        if do_schematic:
            annotate_color = 'k'
            for x_,align_ in [(0.03,'center'), (1.97,'center')]:
                plt.text(x_,0.45, 'rays initiated', #transform=axes.transAxes,
                         rotation=0, horizontalalignment=align_, verticalalignment='center',
                         fontsize=12, color='r')
            plt.text(1,0.53, 'rays annihilated', #transform=axes.transAxes,
                     rotation=0, horizontalalignment='center', verticalalignment='center',
                     fontsize=12, color='0.25')
            for x_,align_ in [(-0.03,'right'), (2.03,'left')]:
                plt.text(x_,0.17, 'fault slip b.c.' if do_fault_bdry else 'const. erosion rate',
                         rotation=90, horizontalalignment=align_, verticalalignment='center',
                         fontsize=12, color='r', alpha=0.7)
            plt.text(0.46,0.38, r'surface isochrone $T(\mathbf{r})=\mathrm{past}$',
                     #transform=axes.transAxes,
                     rotation=12, horizontalalignment='center', verticalalignment='center',
                     fontsize=10, color='0.2')
            plt.text(0.52,0.05, r'surface isochrone $T(\mathbf{r})=\mathrm{now}$',
                     #transform=axes.transAxes,
                     rotation=12, horizontalalignment='center', verticalalignment='center',
                     fontsize=10, color='k')
            for x_,y_,dx_,dy_,shape_ in [(0,0.4, 0,-0.15,'left'), (0,0.25, 0,-0.15,'left'),
                                         (0,0.1, 0,-0.15,'left'), (2,0.4, 0,-0.15,'right'),
                                         (2,0.25, 0,-0.15,'right'),(2,0.1, 0,-0.15,'right')]:
                plt.arrow( x_,y_,dx_,dy_, head_length=0.04, head_width=0.03,
                           length_includes_head=True, shape=shape_,
                           facecolor='r', edgecolor='r' )

    def profile_h( self, gmes, gmeq, sub, name, fig_size=None, dpi=None,
                    y_limits=None, eta_label_xy=None, n_points=101,
                    do_direct=True,  do_legend=True, do_profile_points=True,
                    profile_subsetting=5,
                    do_t_sampling=True, do_etaxi_label=True,
                    do_pub_label=False, pub_label='', pub_label_xy=[0.93,0.33] ):
        r"""
        Plot a time-invariant topographic profile solution of Hamilton's equations.


        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)
        axes = plt.gca()

        t_array  = gmes.t_array #[::ray_subsetting]
        rx_array = gmes.rx_array #[::ray_subsetting]
        rz_array = gmes.rz_array #[::ray_subsetting]
        print()

        if do_t_sampling:
            t_begin, t_end = t_array[0], t_array[-1]
            t_rsmpld_array = np.linspace(t_begin, t_end, n_points)
        else:
            x_rsmpld_array = np.linspace(rx_array[0], rx_array[-1], n_points)
            t_rsmpld_array = gmes.t_interp_x(x_rsmpld_array)
        rx_rsmpld_array = gmes.rx_interp_t(t_rsmpld_array)
        rz_rsmpld_array = gmes.rz_interp_t(t_rsmpld_array)

        # Markers = topo profile from ray terminations
        plt.plot( gmes.x_array[::profile_subsetting], gmes.h_array[::profile_subsetting],
                    'k'+('s' if do_profile_points else '-'),
                    ms=3, label=r'$T(\mathbf{r})$ from rays $\mathbf{r}(t)$' )

        # Solid line = topo profile from direct integration of gradient array
        plt.plot(gmes.h_x_array,(gmes.h_z_array-gmes.h_z_array[0]), 'k',
                 label='$T(\mathbf{r})$ by integration' )
        axes.set_aspect(1)
        plt.grid(True, ls=':')
        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=15)
        plt.ylabel(r'Elevation, $z/L_{\mathrm{c}}$  [-]', fontsize=15)
        if do_legend:
            plt.legend(loc=(0.38,0.75),
                       fontsize=9 if do_schematic else 11,
                       framealpha=0.95)
        if eta_label_xy is None:
            eta_label_xy = (0.92,0.15)
        if do_etaxi_label:
            plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
                     transform=axes.transAxes,
                     horizontalalignment='center', verticalalignment='center',
                     fontsize=16, color='k')
        if do_pub_label:
            plt.text(*pub_label_xy, pub_label,
                     transform=axes.transAxes, horizontalalignment='center', verticalalignment='center',
                     fontsize=16, color='k')
        if y_limits is not None:
            plt.ylim(*y_limits)

    def alpha_beta( self, gmes, gmeq, sub, name, fig_size=None, dpi=None, aspect=1,
                    n_points=201, x_limits=None, y_limits=None, do_legend=True,
                    do_etaxi_label=True, eta_label_xy=None,
                    do_pub_label=False, pub_label='', pub_label_xy=None ):
        r"""
        Plot ray vector angle :math:`\alpha` versus normal-slowness covector angle :math:`\beta`
        generated by a time-invariant solution.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): optional sample rate along each curve
            x_limits (list of float):
                optional [x_min, x_max] horizontal plot range
            y_limits (list of float):
                optional [z_min, z_max] vertical plot range
            do_legend (bool): optional plot legend?
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)
        eta_label_xy = [0.5,0.85] if eta_label_xy is None else eta_label_xy
        pub_label_xy = [0.88,0.7] if pub_label_xy is None else pub_label_xy

        x_array = np.linspace(0,1,n_points)
        alpha_array = np.rad2deg(gmes.alpha_interp(x_array))
        beta_p_array = np.rad2deg(gmes.beta_p_interp(x_array))
        plt.plot( beta_p_array, alpha_array-90, 'b', ls='-', label=r'$\alpha(\beta)-90$')
        plt.xlabel(r'Surface normal angle  $\beta$  [${\degree}$ from vertical]')
        plt.ylabel(r'Ray angle  $\alpha\,$  [${\degree}$ from horiz]')
        plt.grid(True, ls=':')

        axes = plt.gca()
        axes.set_aspect(aspect)
        xlim = axes.get_xlim()
        ylim = axes.get_ylim()
        axes.set_yticks([-40,-30,-20,-10,0,10,20,30,40,50,60,70,80,90])
        if x_limits is None:
            axes.set_xlim( -(xlim[1]-xlim[0])/30,xlim[1] )
        else:
            axes.set_xlim(*x_limits)
        if y_limits is not None:
            axes.set_ylim(*y_limits)
        if do_legend:
            plt.legend()
        if do_etaxi_label:
            # plt.text(0.5,0.85, r'$\eta={}$'.format(gmeq.eta),
            plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
                     transform=axes.transAxes,
                     horizontalalignment='center', verticalalignment='center', fontsize=14, color='k')
        if do_pub_label:
            plt.text(*pub_label_xy, pub_label,
            transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=16, color='k')

    def angular_disparity( self, gmes, gmeq, sub, name, fig_size=None, dpi=None,
                           n_points=201, x_limits=None, y_limits=None, do_legend=True,
                           aspect=0.75,
                           pub_label_xy=[0.5,0.2], eta_label_xy=[0.5,0.81], var_label_xy=[0.85,0.81],
                           do_pub_label=False, pub_label='' ):
        r"""
        Plot ray vector angular disparity :math:`\alpha-\beta`
        generated by a time-invariant solution.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): optional sample rate along each curve
            x_limits (list of float):
                optional [x_min, x_max] horizontal plot range
            y_limits (list of float):
                optional [z_min, z_max] vertical plot range
            do_legend (bool): optional plot legend?
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)

        x_array = np.linspace(0,1,n_points)
        alpha_array = np.rad2deg(gmes.alpha_interp(x_array))
        beta_p_array = np.rad2deg(gmes.beta_p_interp(x_array))
        plt.plot( beta_p_array, alpha_array-beta_p_array, 'DarkBlue', ls='-', label=r'$\alpha(\beta)-90$')
        plt.xlabel(r'Surface normal angle  $\beta$  [${\degree}$ from vertical]')
        plt.ylabel(r'Angular disparity  $(\alpha-\beta\!)+90\,$  [${\degree}$]')
        plt.grid(True, ls=':')

        axes = plt.gca()
        axes.set_aspect(aspect)
        xlim = axes.get_xlim()
        # ylim = axes.get_ylim()
        axes.set_yticks([-20,-10,0,10,20,30,40,50,60,70,80,90])
        if x_limits is None:
            axes.set_xlim( -(xlim[1]-xlim[0])/30,xlim[1] )
        else:
            axes.set_xlim(*x_limits)
        if y_limits is not None:
            axes.set_ylim(*y_limits)
        if do_legend:
            plt.legend()
        plt.text(*eta_label_xy, r'$\eta={}$'.format(gmeq.eta), transform=axes.transAxes,
                 horizontalalignment='center', verticalalignment='center', fontsize=14, color='k')
        if do_pub_label:
            plt.text(*pub_label_xy, pub_label,
            transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=16, color='k')

    def profile_angular_disparity( self, gmes, gmeq, sub, name, fig_size=None, dpi=None, n_points=201,
                                   pub_label_xy=[0.5,0.2], eta_label_xy=[0.25,0.5], var_label_xy=[0.8,0.35],
                                   do_pub_label=False, pub_label='(a)' ):
        r"""
        Plot horizontal erosion speed :math:`\xi^{\rightarrow}` along a time-invariant profile.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): sample rate along each curve
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)

        x_array = np.linspace(0,1,n_points)
        # x_dbl_array = np.linspace(0,1,n_points*2-1)
        angular_diff_array = np.rad2deg(gmes.alpha_interp(x_array)-gmes.beta_p_interp(x_array))
        plt.plot(x_array,angular_diff_array, 'DarkBlue', ls='-', lw=1.5, label=r'$\alpha(x)-\beta(x)$')
        axes = plt.gca()
        ylim = plt.ylim()
        axes.set_yticks([-30,0,30,60,90])
        axes.set_ylim( -5,95 )
        plt.grid(True, ls=':')

        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=13)
        plt.ylabel(r'Anisotropy,  $\psi = \alpha-\beta+90$  [${\degree}$]', fontsize=12)
        if not do_pub_label:
            plt.legend(loc='lower left', fontsize=11, framealpha=0.95)
        plt.text(*pub_label_xy, pub_label if do_pub_label else r'$\eta={}$'.format(gmeq.eta),
                 transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=16, color='k')
        plt.text(*var_label_xy, r'$\psi(x)$' if do_pub_label else '',
                 transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=18, color='k')
        plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
                 transform=axes.transAxes,
                 horizontalalignment='center', verticalalignment='center', fontsize=14, color='k')

    def profile_alpha( self, gmes, gmeq, sub, name, fig_size=None, dpi=None, n_points=201, do_legend=True):
        r"""
        Plot ray vector angle :math:`\alpha` along a time-invariant profile.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): optional sample rate along each curve
            do_legend (bool): optional plot legend?
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)

        x_array = np.linspace(0,1,n_points)
        alpha_array = np.rad2deg(gmes.alpha_interp(x_array))
        plt.plot(x_array,alpha_array-90, 'DarkBlue', ls='-', label=r'$\alpha(x)$')
        x_array = np.linspace(0,1,11)
        pz0_ = gmes.pz0
        alpha_array = [(np.mod(180+np.rad2deg(float(
            atan(gmeq.tanalpha_pxpz_eqn.rhs.subs({px:gmes.px_value(x_,pz0_),pz:pz0_})))),180))
            for x_ in x_array]
        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]')
        plt.ylabel(r'Ray dip  $\alpha\!\,$  [${\degree}$ from horiz]')
        plt.grid(True, ls=':')

        if do_legend:
            plt.legend()
        axes = plt.gca()
        plt.text(0.5,0.7, r'$\eta={}$'.format(gmeq.eta), transform=axes.transAxes,
                 horizontalalignment='center', verticalalignment='center', fontsize=14, color='k')

    def profile_v( self, gmes, gmeq, sub, name, fig_size=None, dpi=None, n_points=201,
                   pub_label_xy=[0.5,0.5], eta_label_xy=[0.5,0.81], var_label_xy=[0.8,0.5],
                   do_pub_label=False, pub_label='', do_etaxi_label=True,
                   xi_norm=None, legend_loc='lower right', do_mod_v=False ):
        r"""
        Plot velocity :math:`\dot{r}` along a ray.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): sample rate along each curve
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)

        if xi_norm is None:
            xi_norm = 1
            rate_label = '${v}$'
        else:
            xi_norm = float(N(xi_norm))
            rate_label = r'${v}/\xi^{\!\rightarrow_{\!\!0}}$  [-]'
        rx_array = gmes.rx_array
        x_min, x_max = rx_array[0], rx_array[-1]
        x_array = np.linspace(x_min, x_max,n_points)
        t_array  = gmes.t_interp_x(x_array)
        vx_array = gmes.rdotx_interp(x_array)/xi_norm
        vz_array = gmes.rdotz_interp(x_array)/xi_norm
        v_array = np.sqrt(vx_array**2+vz_array**2)
        vx_max = np.max(np.abs(vx_array))
        vz_max = np.max(np.abs(vz_array))
        v_max = np.max((v_array))

        if do_mod_v:
            plt.plot( x_array, v_array, 'DarkBlue', ls='-', lw=1.5, label=r'${v}(x)$')
            plt.ylabel(r'Ray speed  '+rate_label, fontsize=13)
            legend_loc = 'lower left'
        else:
            sfx = np.power(10,np.round(np.log10(vz_max/v_max),0))
            label_suffix = '' if sfx==1 else r'$\,\times\,$'+f'{sfx}'
            plt.plot( x_array, vx_array*sfx, 'r', ls='-', lw=1.5,
                                label=r'${v}^x(x)$'+label_suffix)
            plt.plot( x_array, vz_array, 'b', ls='-', lw=1.5,
                                label=r'${v}^z(x)$')
            plt.ylabel(r'Ray velocity  '+rate_label, fontsize=13)

        axes = plt.gca()
        ylim = plt.ylim()
        if ylim[1]<0: axes.set_ylim(ylim[0],0)
        if ylim[0]>0: axes.set_ylim(0,ylim[1])
        # axes.set_ylim( -(ylim[1]-ylim[0])/20,ylim[1] )
        plt.grid(True, ls=':')
        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=13)
        plt.legend(loc=legend_loc, fontsize=14, framealpha=0.95)
        if do_etaxi_label:
            plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
                     transform=axes.transAxes,
                     horizontalalignment='center', verticalalignment='center',
                     fontsize=16, color='k')
        if do_pub_label:
            plt.text(*pub_label_xy, pub_label,
                     transform=axes.transAxes, horizontalalignment='center', verticalalignment='center',
                     fontsize=16, color='k')
        plt.text(*var_label_xy, r'${v}(x)$' if do_mod_v else r'$\mathbf{v}(x)$',
                 transform=axes.transAxes, horizontalalignment='center', verticalalignment='center', fontsize=18, color='k')

    def profile_vdot( self, gmes, gmeq, sub, name, fig_size=None, dpi=None,
                      n_points=201, do_pub_label=False, pub_label='', xi_norm=None, do_etaxi_label=True,
                      legend_loc='lower right', do_legend=True, do_mod_vdot=False, do_geodesic=False ):
        r"""
        Plot acceleration :math:`\ddot{r}` along a ray.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): sample rate along each curve
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)

        # Use an erosion rate (likely vertical xi) to renormalize velocities and accelns (up to T)
        if xi_norm is None:
            xi_norm = 1
            rate_label = '$\dot{v}$'
        else:
            xi_norm = float(N(xi_norm))
            rate_label = r'$\dot{v}/\xi^{\!\rightarrow_{\!\!0}}$  [T$^{-1}$]'

        # Specify sampling in x and t
        rx_array = gmes.rx_array
        x_min, x_max = rx_array[0], rx_array[-1]
        x_array = np.linspace(x_min, x_max,n_points)
        t_array  = gmes.t_interp_x(x_array)

        # Get ray velocities
        vdotx_array = gmes.rddotx_interp_t(t_array)/xi_norm
        vdotz_array = gmes.rddotz_interp_t(t_array)/xi_norm
        vdot_array = np.sqrt(vdotx_array**2+vdotz_array**2)

        # Prep to set vertical axis to span vdotz and thus scale vdotx to fit
        vdotx_max = np.max(np.abs(vdotx_array))
        vdotz_max = np.max(np.abs(vdotz_array))
        vdot_max = np.max((vdot_array))

        # Start doing some plotting
        sfx = 1 if np.abs(vdotz_max)<1e-20 else np.power(10,np.round(np.log10(vdotz_max/vdot_max),0))
        label_suffix = '' if sfx==1 else r'$\,\times\,$'+f'{sfx}'
        choice = '_\mathrm{hmltn}'
        vdotx_label = r'$\dot{v}^x'+choice+'(x)$'+label_suffix
        vdotz_label = r'$\dot{v}^z'+choice+'(x)$'
        if do_mod_vdot:
            plt.plot( x_array, vdot_array, 'DarkBlue', ls='-', lw=1.5, label=r'$\dot{v}'+choice+'(x)$')
            plt.ylabel(r'Ray acceleration  '+rate_label, fontsize=13)
            legend_loc = 'lower left'
        else:
            plt.plot( x_array, vdotx_array*sfx, 'r', ls='-', lw=1.5, label=vdotx_label)
            plt.plot( x_array, vdotz_array, 'b', ls='-', lw=1.5, label=vdotz_label)
            plt.ylabel(r'Ray acceleration  '+rate_label, fontsize=14)

        ylim = plt.ylim()

        # Geodesic computation of acceln using Christoffel symbols
        if do_geodesic and hasattr(gmeq,'vdotx_lambdified') and hasattr(gmeq,'vdotz_lambdified')\
                        and gmeq.vdotx_lambdified is not None and gmeq.vdotz_lambdified is not None:
            vx_array = gmes.rdotx_interp(x_array)
            vz_array = gmes.rdotz_interp(x_array)
            vdotx_gdsc_array = np.array([gmeq.vdotx_lambdified(float(x), float(vx), float(vz), varepsilon.subs(sub))/xi_norm
                                        for x,vx,vz in zip(x_array, vx_array, vz_array)])
            vdotz_gdsc_array = np.array([gmeq.vdotz_lambdified(float(x), float(vx), float(vz), varepsilon.subs(sub))/xi_norm
                                        for x,vx,vz in zip(x_array, vx_array, vz_array)])
            vdot_gdsc_array = np.sqrt(vdotx_gdsc_array**2+vdotz_gdsc_array**2)
            vdotx_label = r'$\dot{v}^x_\mathrm{gdsc}(x)$'+label_suffix
            vdotz_label = r'$\dot{v}^z_\mathrm{gdsc}(x)$'
            if do_mod_vdot:
                plt.plot( x_array, vdot_gdsc_array, 'DarkBlue', ls=':', lw=3,
                            label=r'$\dot{v}_\mathrm{gdsc}(x)$')
                plt.ylabel(r'Ray acceleration  '+rate_label, fontsize=13)
                legend_loc = 'lower left'
            else:
                plt.plot( x_array, vdotx_gdsc_array*sfx, 'DarkRed', ls=':', lw=3, label=vdotx_label)
                plt.plot( x_array, vdotz_gdsc_array, 'DarkBlue', ls=':', lw=3, label=vdotz_label)


        # Misc pretty stuff
        axes = plt.gca()
        # if ylim[1]<0: axes.set_ylim(ylim[0],0)
        # if ylim[0]>0: axes.set_ylim(0,ylim[1])
        # axes.set_ylim( -(ylim[1]-ylim[0])/20,ylim[1] )
        axes.set_ylim(*ylim)
        plt.grid(True, ls=':')

        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=14)
        # axes.set_ylim(ylim[0]*1.1,-0)
        if do_legend: plt.legend(loc=legend_loc, fontsize=13, framealpha=0.95)
        if do_etaxi_label:
            plt.text(0.6,0.8, pub_label if do_pub_label else r'$\eta={}$'.format(gmeq.eta),
                     transform=axes.transAxes,
                     horizontalalignment='center', verticalalignment='center', fontsize=14, color='k')

    def prep_g_arrays( self, gmes, gmeq, n_points, do_recompute=False ):
        if not hasattr(self,'x_array') or n_points!=len(self.x_array):
            do_recompute=True
            print('(Re)computing g matrices')

        rx_array = gmes.rx_array
        x_min, x_max = rx_array[0], rx_array[-1]
        self.x_array = np.linspace(x_min, x_max, n_points) \
                        if do_recompute or not hasattr(self,'x_array') else self.x_array
        self.t_array  = gmes.t_interp_x(self.x_array) \
                        if do_recompute or not hasattr(self,'t_array') else self.t_array
        self.rz_array = gmes.rz_interp(self.x_array)  \
                        if do_recompute or not hasattr(self,'rz_array') else self.rz_array
        self.vx_array = gmes.rdotx_interp(self.x_array)  \
                        if do_recompute or not hasattr(self,'vx_array') else self.vx_array
        self.vz_array = gmes.rdotz_interp(self.x_array)  \
                        if do_recompute or not hasattr(self,'vz_array') else self.vz_array
        x_array = self.x_array
        t_array  = self.t_array
        rz_array = self.rz_array
        vx_array = self.vx_array
        vz_array = self.vz_array

        if do_recompute:
            self.gstar_matrices_list = None
            self.gstar_matrices_array = None
            self.g_matrices_list = None
            self.g_matrices_array = None
        if not hasattr(gmeq, 'gstar_ij_mat'): return
        try:
            self.gstar_matrices_list = self.gstar_matrices_list \
                                        if not do_recompute and self.gstar_matrices_list is not None \
                                        else [gmeq.gstar_ij_mat.subs({rx:x_,rdotx:vx_,rdotz:vz_})
                                              for x_,vx_,vz_ in zip(x_array,vx_array,vz_array)]
        except Exception as e:
            print(f'Failed to (re)generate gstar_matrices_list: "{e}"')

        try:
            self.gstar_matrices_array = self.gstar_matrices_array \
                                        if not do_recompute and self.gstar_matrices_array is not None \
                                        else [np.array([float(re(elem_)) for elem_ in g_]).reshape(2,2)
                                              for g_ in self.gstar_matrices_list]
        except Exception as e:
            print(f'Failed to (re)generate gstar_matrices_array: "{e}"')

        try:
            self.g_matrices_list = self.g_matrices_list \
                                        if not do_recompute and self.g_matrices_list is not None \
                                        else [gmeq.g_ij_mat.subs({rx:x_,rdotx:vx_,rdotz:vz_})
                                              for x_,vx_,vz_ in zip(x_array,vx_array,vz_array)]
        except Exception as e:
            print(f'Failed to (re)generate g_matrices_list: "{e}"')

        try:
            self.g_matrices_array = self.g_matrices_array \
                                        if not do_recompute and self.g_matrices_array is not None \
                                        else [np.array([float(re(elem_)) for elem_ in g_]).reshape(2,2)
                                              for g_ in self.g_matrices_list]
        except Exception as e:
            print(f'Failed to (re)generate g_matrices_array: "{e}"')

    def profile_g_properties( self, gmes, gmeq, sub, name, fig_size=None, dpi=None,
                              y_limits=[None,None],
                              n_points=121, do_pub_label=False, pub_label='',
                              do_gstar=False, do_det=False, do_eigenvectors=False,
                              eta_label_xy=None, do_etaxi_label=True,
                              legend_loc='lower left', do_mod_v=False, do_pv=False,
                              do_recompute=False ):
        r"""
        Plot velocity :math:`\dot{r}` along a ray.

        Args:
            fig (:obj:`Matplotlib figure <matplotlib.figure.Figure>`):
                reference to figure instantiated by :meth:`GMPLib create_figure <plot_utils.GraphingBase.create_figure>`
            gmes (:class:`~.ode_raytracing.OneRaySolution`):
                    instance of single ray solution class defined in :mod:`~.ode_raytracing`
            gmeq (:class:`~.equations.Equations`):
                    GME model equations class instance defined in :mod:`~.equations`
            n_points (int): sample rate along each curve
        """
        fig = self.create_figure(name, fig_size=fig_size, dpi=dpi)
        axes = plt.gca()

        self.prep_g_arrays(gmes, gmeq, n_points, do_recompute)
        if do_gstar:
            g_matrices_array = self.gstar_matrices_array
        else:
            g_matrices_array = self.g_matrices_array
        x_array = self.x_array
        t_array  = self.t_array
        rz_array = self.rz_array
        vx_array = self.vx_array
        vz_array = self.vz_array

        if do_gstar:
            # Use of lambdified g matrix here fails for eta=1/4, sin(beta) for some reason
            # g_matrices_list = [gmeq.gstar_ij_mat_lambdified(x_,vx_,vz_)
            #                         for x_,vx_,vz_ in zip(x_array,vx_array,vz_array)]
            g_label = '{g^*}'
            m_label = 'co-metric'
            h_label = 'H'
            eta_label_xy = [0.5,0.2] if eta_label_xy is None else eta_label_xy
        else:
            # Use of lambdified g* matrix here fails for eta=1/4, sin(beta) for some reason
            # g_matrices_list = [gmeq.g_ij_mat_lambdified(x_,vx_,vz_)
            #                     for x_,vx_,vz_ in zip(x_array,vx_array,vz_array)]
            g_label = '{g}'
            m_label = 'metric'
            h_label = 'L'
            eta_label_xy = [0.5,0.85] if eta_label_xy is None else eta_label_xy
        # g_eigenvalues_array = np.array([np.real(eig(g_)[0]) for g_ in g_matrices_array])
        # The metric tensor matrices are symmetric therefore Hermitian so we can use 'eigh'
        # print(f'g_matrices_array = {g_matrices_array}')
        if g_matrices_array is not None:
            g_eigh_array = [eigh(g_) for g_ in g_matrices_array]
            g_det_array = np.array([det(g_) for g_ in g_matrices_array])
        else:
            g_eigh_array = None
            g_det_array = None
        if g_eigh_array is not None:
            g_eigenvalues_array = np.real(np.array( [g_eigh_[0] for g_eigh_ in g_eigh_array] ))
            g_eigenvectors_array = np.real(np.array( [g_eigh_[1] for g_eigh_ in g_eigh_array] ))
        else:
            g_eigenvalues_array = None
            g_eigenvectors_array = None
        if do_eigenvectors and g_eigenvectors_array is not None:
            plt.plot( x_array, rz_array, '0.6', ls='-', lw=3, label=r'ray')
            plt.ylabel(r'Eigenvectors of $'+g_label+'$', fontsize=14)
            arrow_sf = 0.5
            my_arrow_style = mpatches.ArrowStyle.Fancy(head_length=0.99*arrow_sf, head_width=0.6*arrow_sf,
                                                       tail_width=0.01*arrow_sf)
            step = 8
            off = 0*step//2
            ev_sf = 0.04
            zipped_arrays = zip(x_array[off::step], rz_array[off::step], g_eigenvectors_array[off::step])
            for x_,rz_,evs_ in zipped_arrays:
                xy_ = np.array([x_,rz_])
                [axes.annotate('', xy=xy_+pm*evs_[0]*ev_sf, xytext=xy_,
                        arrowprops={'arrowstyle':my_arrow_style, 'color':'magenta'} ) for pm in (-1,+1)]
                [axes.annotate('', xy=xy_+pm*evs_[1]*ev_sf, xytext=xy_,
                        arrowprops={'arrowstyle':my_arrow_style, 'color':'DarkGreen'} ) for pm in (-1,+1)]
            plt.plot( 0, 0, 'DarkGreen', ls='-', lw=1.5, label='eigenvector 0')
            plt.plot( 0, 0, 'magenta', ls='-', lw=1.5, label=r'eigenvector 1')
            axes.set_aspect(1)
        elif do_det and g_det_array is not None:
            plt.plot( x_array, g_det_array, 'DarkBlue', ls='-', lw=1.5,
                            label=r'$\det('+g_label+')$')
            plt.ylabel(r'Det of $'+g_label+'$ (Hessian of $'+h_label+'$)', fontsize=14)
        elif do_pv:
            px_array = gmes.px_interp(x_array)
            pz_array = gmes.pz_interp(x_array)
            pv_array = px_array*vx_array + pz_array*vz_array
            plt.plot( x_array, pv_array, 'r', ls='-', lw=2, label=r'$p_i v^i$')
            if self.gstar_matrices_array is not None:
                gstarpp_array = [np.dot(np.dot(gstar_, np.array([px_, pz_])),np.array([px_, pz_]))
                             for gstar_, px_, pz_ in zip(self.gstar_matrices_array, px_array, pz_array)]
                plt.plot( x_array, gstarpp_array, '0.5', ls='--', lw=3, label=r'$g^j p_j p_j$')
            if self.g_matrices_array is not None:
                gvv_array = [np.dot(np.dot(g_, np.array([vx_, vz_])),np.array([vx_, vz_]))
                             for g_, vx_, vz_ in zip(self.g_matrices_array, vx_array, vz_array)]
                plt.plot( x_array, gvv_array, 'k', ls=':', lw=4, label=r'$g_i v^iv^i$')
            plt.ylabel(r'Inner product of $\mathbf{\widetilde{p}}$ and $\mathbf{{v}}$', fontsize=14)
            legend_loc = 'upper left'
        elif g_eigenvalues_array is not None:
            sign_ev0,label_ev0 = (-1,'negative  ') if g_eigenvalues_array[0,0]<0 else (1,'positive  ')
            sign_ev1,label_ev1 = (-1,'negative  ') if g_eigenvalues_array[0,1]<0 else (1,'positive  ')
            plt.yscale('log')
            plt.plot( x_array, sign_ev1*(g_eigenvalues_array[:,1]), 'DarkGreen', ls='-', lw=1.5,
                            label=r''+label_ev1+'$\lambda_'+g_label+'(1)$')
            plt.plot( x_array, sign_ev0*(g_eigenvalues_array[:,0]), 'magenta', ls='-', lw=1.5,
                            label=r''+label_ev0+'$\lambda_'+g_label+'(0)$')
            plt.ylabel(r'Eigenvalues of '+m_label+' tensor $'+g_label+'$', fontsize=12)
        else:
            return

        if do_eigenvectors:
            axes.set_ylim(*y_limits)
        elif do_det:
            ylim = plt.ylim()
            if ylim[1]<0: axes.set_ylim(ylim[0],0)
            if ylim[0]>0: axes.set_ylim(0,ylim[1])
            # axes.set_ylim( -(ylim[1]-ylim[0])/20,ylim[1] )
        elif do_pv:
            axes.set_ylim(0,2)
        plt.grid(True, ls=':')
        plt.xlabel(r'Distance, $x/L_{\mathrm{c}}$  [-]', fontsize=14)
        # axes.set_ylim(ylim[0]*1.1,-0)
        plt.legend(loc=legend_loc, fontsize=12, framealpha=0.95)
        if do_etaxi_label:
            plt.text(*eta_label_xy, r'$\eta='+rf'{gmeq.eta}'+r'\quad\mathsf{Ci}='+rf'{round(float(deg(Ci.subs(sub))))}'+'{\degree}$',
            # plt.text(*eta_label_xy, pub_label if do_pub_label else r'$\eta={}$'.format(gmeq.eta),
                     transform=axes.transAxes,
                     horizontalalignment='center', verticalalignment='center', fontsize=14, color='k')
