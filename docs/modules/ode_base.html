<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ode_base.py &#8212; GME 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ode_raytracing.py" href="ode_raytracing.html" />
    <link rel="prev" title="equations.py" href="equations.html" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <link rel="shortcut icon" type="image/png" href="../_static/favicon.png" />
    <meta name="viewport" content="width=device-width,initial-scale=0.8">
    
    

  </head><body>
    <!-- <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="responsive-menu"><a href="#sidebar-anchor" title="Navigation">&#9776;</a></li>
        <li><a href="../index.html">GME 1.0 documentation</a> &#187;</li>
          <li><a href="Python.html" accesskey="U">Python package <cite>gme</cite></a> &#187;</li> 
      </ul>
    </div> -->
    <!-- 
        <div class="badge">
            <a href="https://github.com/cstarkjp/GME/">Fork me on GitHub</a>
            <img src="../_static/right-red@2x.png">
        </div>
     -->
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-gme.ode_base">
<span id="ode-base-py"></span><h1><code class="docutils literal notranslate"><span class="pre">ode_base.py</span></code><a class="headerlink" href="#module-gme.ode_base" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>ODE integration of Hamilton’s equations.</p>
<hr class="docutils" />
<dl class="simple">
<dt>Requires Python packages/modules:</dt><dd><ul class="simple">
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">gmplib.utils</span></code></p></li>
<li><p><a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.21)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a></p></li>
<li><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy" title="(in SciPy v1.7.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code></a></p></li>
<li><p><a class="reference external" href="https://docs.sympy.org/latest/modules/index.html#module-sympy" title="(in SymPy v1.8)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy</span></code></a></p></li>
</ul>
</dd>
</dl>
<p>Imports symbols from <a class="reference internal" href="symbols.html#module-gme.symbols" title="gme.symbols"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symbols</span></code></a> module</p>
<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="gme.ode_base.BaseSolution">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">gme.ode_base.</span></span><span class="sig-name descname"><span class="pre">BaseSolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gmeq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Hamilton'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Radau'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xf_stop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.04</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_slip_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_distribn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">101</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_xiv0_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">customize_t_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gme.ode_base.BaseSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for  classes performing integration of Hamilton’s equations (ODEs).</p>
<dl class="py method">
<dt class="sig sig-object py" id="gme.ode_base.BaseSolution.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gmeq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Hamilton'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Radau'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xf_stop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.04</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_slip_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_distribn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">101</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp_xiv0_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">customize_t_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gme.ode_base.BaseSolution.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gmeq</strong> (<a class="reference internal" href="equations.html#gme.equations.Equations" title="gme.equations.Equations"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equations</span></code></a>) – GME model equations class instance defined in <a class="reference internal" href="equations.html#module-gme.equations" title="gme.equations"><code class="xref py py-mod docutils literal notranslate"><span class="pre">equations</span></code></a></p></li>
<li><p><strong>parameters</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><em>dict</em></a>) – dictionary of model parameter values to be used for equation substitutions</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gme.ode_base.BaseSolution.resolve_isochrones">
<span class="sig-name descname"><span class="pre">resolve_isochrones</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_isochrone_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.04</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_isochrones</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds_hack</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_eliminate_caustics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dont_crop_cusps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gme.ode_base.BaseSolution.resolve_isochrones" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the ensemble of rays at selected time slices to generate
synchronous values of (r,p) aka isochrones.</p>
<p>Each ray trajectory is numerically integrated independently, and so the integration points along one ray are
not synchronous with those of any other ray. If we want to compare the (r,p) “positions” of the ray ensemble
at a chosen time, we need to resample along all the rays at mutually consistent time slices.
This is achieved by first interpolating along each rx[t], rz[t], pz[t], and pz[t] sequence, and then
resampling along a reference time sequence.</p>
<dl class="simple">
<dt>Two additional actions are taken:</dt><dd><ol class="arabic simple">
<li><p>termination of each resampled ray at the domain boundary at rx=x_1 (or a bit beyond, for better viz quality);</p></li>
<li><p>termination of any resampled ray that is overtaken by another ray at a cusp.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="code">
<h2>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">---------------------------------------------------------------------</span>

<span class="sd">ODE integration of Hamilton&#39;s equations.</span>

<span class="sd">---------------------------------------------------------------------</span>

<span class="sd">Requires Python packages/modules:</span>
<span class="sd">  -  :mod:`gmplib.utils`</span>
<span class="sd">  -  :mod:`numpy`</span>
<span class="sd">  -  :mod:`scipy`</span>
<span class="sd">  -  :mod:`sympy`</span>

<span class="sd">Imports symbols from :mod:`.symbols` module</span>

<span class="sd">---------------------------------------------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">gmplib.utils</span> <span class="kn">import</span> <span class="n">vprint</span><span class="p">,</span> <span class="n">e2d</span>
<span class="kn">from</span> <span class="nn">gme.symbols</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">N</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">atan</span><span class="p">,</span> <span class="n">atan2</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> \
    <span class="n">Matrix</span><span class="p">,</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> <span class="n">expand</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> \
    <span class="n">nroots</span><span class="p">,</span> <span class="n">poly</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span><span class="p">,</span> <span class="n">cumtrapz</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">,</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root_scalar</span><span class="p">,</span> <span class="n">fsolve</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

<span class="n">rp_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">,</span><span class="s1">&#39;rz&#39;</span><span class="p">,</span><span class="s1">&#39;px&#39;</span><span class="p">,</span><span class="s1">&#39;pz&#39;</span><span class="p">]</span>
<span class="n">rpt_list</span> <span class="o">=</span> <span class="n">rp_list</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BaseSolution&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">BaseSolution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for  classes performing integration of Hamilton&#39;s equations (ODEs).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">gmeq</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                  <span class="n">choice</span><span class="o">=</span><span class="s1">&#39;Hamilton&#39;</span><span class="p">,</span>
                  <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Radau&#39;</span><span class="p">,</span> <span class="n">do_dense</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xf_stop</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span>
                  <span class="n">t_end</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span> <span class="n">t_slip_end</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">t_distribn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                  <span class="n">n_rays</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">n_t</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span>
                  <span class="n">tp_xiv0_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">customize_t_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize class instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            gmeq (:class:`~.equations.Equations`):</span>
<span class="sd">                    GME model equations class instance defined in :mod:`~.equations`</span>
<span class="sd">            parameters (dict): dictionary of model parameter values to be used for equation substitutions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Container for GME equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span> <span class="o">=</span> <span class="n">gmeq</span>

        <span class="c1"># Model/equation parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># ODE solution method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choice</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">choice</span><span class="o">==</span><span class="s1">&#39;Hamilton&#39;</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Solve Hamilton</span><span class="se">\&#39;</span><span class="s1">s ODEs&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;Solve geodesic ODEs&#39;</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39; using </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1"> method of integration&#39;</span>
        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_dense</span> <span class="o">=</span> <span class="n">do_dense</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xf_stop</span> <span class="o">=</span> <span class="n">xf_stop</span>

        <span class="c1"># Rays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tp_xiv0_list</span> <span class="o">=</span> <span class="n">tp_xiv0_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_rays</span> <span class="o">=</span> <span class="n">n_rays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_end</span> <span class="o">=</span> <span class="n">t_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_distribn</span> <span class="o">=</span> <span class="n">t_distribn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_slip_end</span> <span class="o">=</span> <span class="n">t_slip_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_t</span> <span class="o">=</span> <span class="n">n_t</span>
        <span class="c1"># To record the longest ray time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_ensemble_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Ray interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp1d_kind</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>

        <span class="c1"># ODEs &amp; related</span>
        <span class="c1"># HACK: clumsy way to sub in value of mu</span>
        <span class="n">pzpx_unity_eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">pzpx_unity_eqn</span>
        <span class="n">px_poly_tmp</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">pzpx_unity_eqn</span>
                              <span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">varphi</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">varphi_rx_eqn</span><span class="o">.</span><span class="n">rhs</span><span class="p">})</span>
                              <span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">mu</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">mu</span><span class="p">})</span>
                              <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">px_poly_lambda</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span> <span class="p">[</span><span class="n">rx</span><span class="p">,</span><span class="n">pz</span><span class="p">],</span> <span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">px_poly_tmp</span><span class="p">))</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pz_velocity_boundary_eqn</span> <span class="o">=</span> <span class="n">gmeq</span><span class="o">.</span><span class="n">pz0_xiv0_eqn</span>
        <span class="c1"># self.px_varphi_xiv_eqn = simplify( Eq( self.gmeq.xiv_varphi_pxpz_eqn.lhs**2/xiv**2,</span>
        <span class="c1">#                                          self.gmeq.xiv_varphi_pxpz_eqn.rhs**2/xiv**2) )</span>
        <span class="c1"># self.px_varphi_xiv_eqn = self.gmeq.px_varphi_xiv_eqn</span>

        <span class="c1"># Initial condition equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">px_initial_surface_eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">px_initial_eqn</span> <span class="c1">#.subs({rx:x})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pz_initial_surface_eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">pz_initial_eqn</span> <span class="c1">#.subs({rx:x})</span>

        <span class="c1"># Misc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_dXdt_lambda</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">customize_t_fn</span> <span class="o">=</span> <span class="n">customize_t_fn</span>

    <span class="k">def</span> <span class="nf">make_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Requires self.parameters to have all the important Hamilton eqns&#39; constants set</span>
        <span class="c1">#   - generates a &quot;matrix&quot; of the 4 Hamilton equations with rx,rz,px,pz as variables</span>
        <span class="c1">#     and the rest as numbers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">choice</span><span class="o">==</span><span class="s1">&#39;Hamilton&#39;</span><span class="p">:</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">do_verbose</span><span class="p">,</span> <span class="s1">&#39;Constructing model Hamilton</span><span class="se">\&#39;</span><span class="s1">s equations&#39;</span><span class="p">)</span>
            <span class="n">drpdt_eqn_matrix</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span> <span class="n">Matrix</span><span class="p">(([</span><span class="n">eq_</span><span class="o">.</span><span class="n">rhs</span> <span class="k">for</span> <span class="n">eq_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">hamiltons_eqns</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="p">]))</span>
                                        <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
                                        <span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">mu</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">mu</span><span class="p">})</span>
                                        <span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="o">-</span><span class="n">pz</span><span class="p">:</span><span class="n">Abs</span><span class="p">(</span><span class="n">pz</span><span class="p">)})</span> <span class="p">)</span>
            <span class="n">drpdt_raw_lambda</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span> <span class="p">[</span><span class="n">rx</span><span class="p">,</span> <span class="n">px</span><span class="p">,</span> <span class="n">pz</span><span class="p">],</span> <span class="n">drpdt_eqn_matrix</span> <span class="p">)</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">t_</span><span class="p">,</span> <span class="n">rp_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span> <span class="n">drpdt_raw_lambda</span><span class="p">(</span><span class="n">rp_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rp_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">rp_</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">do_verbose</span><span class="p">,</span> <span class="s1">&#39;Constructing model geodesic equations&#39;</span><span class="p">)</span>
            <span class="n">drvdt_eqn_matrix</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(([(</span><span class="n">eq_</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">geodesic_eqns</span> <span class="p">]))</span> <span class="c1">#factor</span>
            <span class="n">drvdt_raw_lambda</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span> <span class="p">[</span><span class="n">rx</span><span class="p">,</span> <span class="n">rdotx</span><span class="p">,</span> <span class="n">rdotz</span><span class="p">],</span> <span class="n">drvdt_eqn_matrix</span> <span class="p">)</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">t_</span><span class="p">,</span> <span class="n">rv_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span> <span class="n">drvdt_raw_lambda</span><span class="p">(</span><span class="n">rv_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rv_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">rv_</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">pxpz0_from_xiv0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">px0_poly_eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">poly_px_xiv0_eqn</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">mu</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">mu</span><span class="p">})</span>
        <span class="n">px0_poly_rx0_eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">px0_poly_eqn</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">rx</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>
        <span class="n">px0_poly_lambda</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span> <span class="p">[</span><span class="n">px</span><span class="p">],</span> <span class="n">px0_poly_rx0_eqn</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">dpx0_poly_lambda</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span> <span class="p">[</span><span class="n">px</span><span class="p">],</span> <span class="n">diff</span><span class="p">(</span><span class="n">px0_poly_rx0_eqn</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">as_expr</span><span class="p">(),</span><span class="n">px</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">px0_root_search</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span> <span class="n">px0_poly_lambda</span><span class="p">,</span> <span class="n">fprime</span><span class="o">=</span><span class="n">dpx0_poly_lambda</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mf">0.01</span> <span class="p">)</span>
        <span class="n">px0_</span> <span class="o">=</span> <span class="n">px0_root_search</span><span class="o">.</span><span class="n">root</span>
        <span class="n">pz0_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">pz_xiv_eqn</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">xiv</span><span class="p">:</span><span class="n">xiv_0</span><span class="p">})</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">px0_</span><span class="p">,</span><span class="n">pz0_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">px_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">pz_</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">px_poly</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">px0_poly_eqn</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">rx</span><span class="p">:</span><span class="n">x_</span><span class="p">,</span><span class="n">pz</span><span class="p">:</span><span class="n">pz_</span><span class="p">})</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">mu</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">gmeq</span><span class="o">.</span><span class="n">mu</span><span class="p">}))</span>
        <span class="n">px_poly_roots</span> <span class="o">=</span> <span class="n">nroots</span><span class="p">(</span><span class="n">px_poly</span><span class="p">)</span>
        <span class="n">pxgen</span> <span class="o">=</span> <span class="p">[</span><span class="n">root_</span> <span class="k">for</span> <span class="n">root_</span> <span class="ow">in</span> <span class="n">px_poly_roots</span> <span class="k">if</span> <span class="n">Abs</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">root_</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1e-10</span> <span class="ow">and</span> <span class="n">re</span><span class="p">(</span><span class="n">root_</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">px_poly</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pxgen</span><span class="p">),</span><span class="n">px</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">gradient_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="p">{}):</span>
        <span class="c1"># Hack</span>
        <span class="n">pz_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pz0</span>
        <span class="n">px_</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">px_value</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span><span class="n">pz_</span><span class="p">,</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">px_value</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span><span class="n">pz_</span><span class="p">,</span><span class="n">parameters</span><span class="p">)</span><span class="o">/</span><span class="n">pz_</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">prep_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_t</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">t_distribn</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">rp_</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rays</span><span class="p">})</span> <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rpt_list</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">solve_Hamiltons_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_array</span><span class="p">,</span> <span class="n">t_lag</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">soln_ivp</span><span class="p">,</span> <span class="n">rpt_arrays</span><span class="p">,</span> <span class="n">i_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_ODE_system</span><span class="p">(</span><span class="n">t_array</span><span class="o">=</span><span class="n">t_array</span><span class="p">,</span> <span class="n">t_lag</span><span class="o">=</span><span class="n">t_lag</span><span class="p">,</span>
                                                            <span class="n">xf_stop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xf_stop</span><span class="p">)</span>
        <span class="c1"># print(&#39;solve_Hamiltons_equations #1:&#39;, i_end, len(rpt_arrays[&#39;rx&#39;]), rpt_arrays[&#39;rx&#39;])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solns</span> <span class="o">=</span> <span class="p">[</span><span class="n">soln_ivp</span><span class="p">]</span>
        <span class="c1"># print(f&quot;i_end={i_end}, {len(rpt_arrays[&#39;t&#39;])}, {len(rpt_arrays[&#39;rx&#39;])}&quot;)</span>
        <span class="c1"># if i_end is not None:</span>
        <span class="c1">#     # Bug fix here - shouldn&#39;t be needed?</span>
        <span class="c1">#     if len(rpt_arrays[&#39;rx&#39;]) &lt; i_end: i_end = len(rpt_arrays[&#39;rx&#39;])</span>
        <span class="c1">#     if self.verbose:</span>
        <span class="c1">#         pass</span>
        <span class="c1">#     for rpt_ in rpt_list:</span>
        <span class="c1">#         a = copy(rpt_arrays[rpt_])</span>
        <span class="c1">#         rpt_arrays[rpt_] = a[:i_end]</span>
        <span class="c1"># print(&#39;solve_Hamiltons_equations #2:&#39;, rpt_arrays[&#39;rx&#39;])</span>
        <span class="k">return</span> <span class="n">rpt_arrays</span>

    <span class="k">def</span> <span class="nf">solve_ODE_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_array</span><span class="p">,</span> <span class="n">t_lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xf_stop</span><span class="o">=</span><span class="mf">0.999</span><span class="p">):</span>
        <span class="c1"># Define stop condition</span>
        <span class="k">def</span> <span class="nf">almost_reached_divide</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="c1"># function yielding &gt;0 if rx&lt;x1*xf_stop ~ along profile</span>
            <span class="c1">#              and  &lt;0 if rx&gt;x1*xf_stop ≈ @divide</span>
            <span class="c1">#  - thus triggers an event when rx surpasses x1*xf_stop</span>
            <span class="c1">#    because = zero-crossing in -ve sense</span>
            <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">x_1</span><span class="p">]</span><span class="o">*</span><span class="n">xf_stop</span>
        <span class="n">almost_reached_divide</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Perform ODE integration</span>
        <span class="n">soln_ivp</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_dXdt_lambda</span><span class="p">,</span>
                              <span class="p">[</span><span class="n">t_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">ic</span><span class="p">,</span>
                              <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">t_eval</span><span class="o">=</span><span class="n">t_array</span><span class="p">,</span>
                              <span class="n">dense_output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">do_dense</span><span class="p">,</span>
                              <span class="c1">#min_step=0, #max_step=np.inf,</span>
                              <span class="c1"># rtol=1e-3, atol=1e-6,</span>
                              <span class="n">events</span><span class="o">=</span><span class="n">almost_reached_divide</span><span class="p">,</span>
                              <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>

        <span class="c1"># Process solution</span>
        <span class="n">rp_t_soln</span> <span class="o">=</span> <span class="n">soln_ivp</span><span class="o">.</span><span class="n">y</span>
        <span class="n">rx_array</span><span class="p">,</span> <span class="n">rz_array</span> <span class="o">=</span> <span class="n">rp_t_soln</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rp_t_soln</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Did we exceed the domain bounds?</span>
        <span class="c1"># If so, find the index of the first point out of bounds, otherwise set as None</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">rx_array</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">x_1</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> \
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">rx_array</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">x_1</span><span class="p">]))</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># print(&quot;i_end:&quot;,i_end)</span>
        <span class="k">if</span> <span class="n">i_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rx_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">x_1</span><span class="p">]:</span>
                <span class="n">i_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_array</span><span class="p">),</span><span class="n">i_end</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_array</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Record solution</span>
        <span class="n">rpt_lag_arrays</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">t_lag</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">t_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_lag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t_lag</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">rpt_lag_arrays</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_lag</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_lag</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">rp_idx</span><span class="p">,</span><span class="n">rp_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rp_list</span><span class="p">):</span>
                <span class="n">rpt_lag_arrays</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_lag</span><span class="p">,</span> <span class="n">rp_t_soln</span><span class="p">[</span><span class="n">rp_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_lag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">rpt_idx</span><span class="p">,</span><span class="n">rpt_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rpt_list</span><span class="p">):</span>
                <span class="n">rpt_lag_arrays</span><span class="p">[</span><span class="n">rpt_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">==</span><span class="s1">&#39;very&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;From </span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">: out of bounds @ i=</span><span class="si">{}</span><span class="s1"> x=</span><span class="si">{}</span><span class="s1"> t=</span><span class="si">{}</span><span class="s1">&#39;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rx_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rz_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_lag</span><span class="o">+</span><span class="n">i_end</span> <span class="k">if</span> <span class="n">i_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_array</span><span class="p">),</span>
                                  <span class="n">rx_array</span><span class="p">[</span><span class="n">i_end</span><span class="p">],</span> <span class="n">t_array</span><span class="p">[</span><span class="n">i_end</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;From </span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">: terminating @ i=</span><span class="si">{}</span><span class="s1"> x=</span><span class="si">{}</span><span class="s1"> t=</span><span class="si">{}</span><span class="s1">&#39;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rx_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rz_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_lag</span><span class="o">+</span><span class="n">i_end</span> <span class="k">if</span> <span class="n">i_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_array</span><span class="p">),</span>
                                  <span class="n">rx_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">rpt_arrays</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">rpt_arrays</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rpt_lag_arrays</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span><span class="n">t_array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i_end</span><span class="p">]</span><span class="o">+</span><span class="n">t_lag</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">rp_idx</span><span class="p">,</span><span class="n">rp_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rp_list</span><span class="p">):</span>
            <span class="n">rpt_arrays</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rpt_lag_arrays</span><span class="p">[</span><span class="n">rp_</span><span class="p">],</span><span class="n">rp_t_soln</span><span class="p">[</span><span class="n">rp_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">i_end</span><span class="p">]))</span>
        <span class="c1"># print(&#39;solve_ODE_system:&#39;, rpt_arrays[&#39;rx&#39;])</span>

        <span class="k">return</span> <span class="n">soln_ivp</span><span class="p">,</span> <span class="n">rpt_arrays</span><span class="p">,</span> <span class="p">(</span><span class="n">n_lag</span><span class="o">+</span><span class="n">i_end</span> <span class="k">if</span> <span class="n">i_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_array</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">postprocessing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rp_t_interp_fns</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rp_t_interp_fns</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">rp_</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rays</span><span class="p">})</span> <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">]</span>
        <span class="n">fill_value_</span> <span class="o">=</span> <span class="s1">&#39;extrapolate&#39;</span>
        <span class="k">for</span> <span class="n">i_ray</span><span class="p">,</span> <span class="n">t_array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">t_array</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Generate interpolation functions for each component rx[t], rz[t], px[t], pz[t]</span>
                <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rp_t_interp_fns</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">i_ray</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t_array</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">i_ray</span><span class="p">],</span>
                                                                <span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interp1d_kind</span><span class="p">,</span>
                                                                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value_</span><span class="p">,</span>
                                                                <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resolve_isochrones</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">x_subset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_isochrone_max</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span> <span class="n">n_isochrones</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                            <span class="n">bounds_hack</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">do_eliminate_caustics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dont_crop_cusps</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample the ensemble of rays at selected time slices to generate</span>
<span class="sd">        synchronous values of (r,p) aka isochrones.</span>

<span class="sd">        Each ray trajectory is numerically integrated independently, and so the integration points along one ray are</span>
<span class="sd">        not synchronous with those of any other ray. If we want to compare the (r,p) &quot;positions&quot; of the ray ensemble</span>
<span class="sd">        at a chosen time, we need to resample along all the rays at mutually consistent time slices.</span>
<span class="sd">        This is achieved by first interpolating along each rx[t], rz[t], pz[t], and pz[t] sequence, and then</span>
<span class="sd">        resampling along a reference time sequence.</span>

<span class="sd">        Two additional actions are taken:</span>
<span class="sd">           (1) termination of each resampled ray at the domain boundary at rx=x_1 (or a bit beyond, for better viz quality);</span>
<span class="sd">           (2) termination of any resampled ray that is overtaken by another ray at a cusp.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create isochrones of the evolving surface:</span>
        <span class="c1">#   (1) step through each time t_i in the global time sequence</span>
        <span class="c1">#   (2) for each ray, generate an (rx,rz,px,pz)[t_i] vector through</span>
        <span class="c1">#         interpolation of its numerically integrated sequence</span>
        <span class="c1">#   (3) combine these vectors into arrays for the {rx[t_i]}, {rz[t_i]}, {px[t_i]} and {pz[t_i]}</span>
        <span class="c1">#   (4) truncate a ray from the point where (if at all) its rx sequence reverses and goes left not right</span>
        <span class="c1">#   (5) also truncate if a ray leaves the domain, i.e., rx&gt;x_1</span>

        <span class="k">def</span> <span class="nf">prepare_isochrones</span><span class="p">():</span>
            <span class="c1"># Record important parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_isochrone_max</span> <span class="o">=</span> <span class="n">t_isochrone_max</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_isochrones</span> <span class="o">=</span> <span class="n">n_isochrones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_subset</span> <span class="o">=</span> <span class="n">x_subset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1e-3</span>

            <span class="c1"># Prepare array dictionaries etc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rpt_isochrones</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rpt_isochrones</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">rpt_</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_isochrones</span><span class="p">})</span> <span class="k">for</span> <span class="n">rpt_</span> <span class="ow">in</span> <span class="n">rpt_list</span><span class="p">]</span>
            <span class="c1"># self.rpt_isochrones_lowres = self.rpt_isochrones.copy()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trxz_cusps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">truncate_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">,</span> <span class="n">i_from</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                <span class="n">rpt_isochrone</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">i_from</span><span class="p">:</span><span class="n">i_to</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">rpt_isochrone</span>

        <span class="k">def</span> <span class="nf">find_intercept</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">,</span> <span class="n">slice1</span><span class="p">,</span> <span class="n">slice2</span><span class="p">):</span>
            <span class="n">x1_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">slice1</span><span class="p">]</span>
            <span class="n">x2_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">slice2</span><span class="p">]</span>
            <span class="n">z1_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rz&#39;</span><span class="p">][</span><span class="n">slice1</span><span class="p">]</span>
            <span class="n">z2_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rz&#39;</span><span class="p">][</span><span class="n">slice2</span><span class="p">]</span>
            <span class="n">px1_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;px&#39;</span><span class="p">][</span><span class="n">slice1</span><span class="p">]</span>
            <span class="n">px2_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;px&#39;</span><span class="p">][</span><span class="n">slice2</span><span class="p">]</span>
            <span class="n">pz1_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;pz&#39;</span><span class="p">][</span><span class="n">slice1</span><span class="p">]</span>
            <span class="n">pz2_array</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;pz&#39;</span><span class="p">][</span><span class="n">slice2</span><span class="p">]</span>
            <span class="n">s1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1_array</span><span class="p">))</span>
            <span class="n">s2_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x2_array</span><span class="p">))</span>

            <span class="c1"># Arguments given to interp1d:</span>
            <span class="c1">#  - extrapolate: to make sure we don&#39;t get a fatal value error when fsolve searches</span>
            <span class="c1">#                 beyond the bounds of [0,1]</span>
            <span class="c1">#  - copy: use refs to the arrays</span>
            <span class="c1">#  - assume_sorted: because s_array (&#39;x&#39;) increases monotonically across [0,1]</span>

            <span class="n">kwargs_</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x1_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">x1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">x2_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">x2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">z1_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">z1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">z2_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">z2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">px1_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">px1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">px2_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">px2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">pz1_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">pz1_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">pz2_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span><span class="n">pz2_array</span><span class="p">[</span><span class="nb">slice</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>

            <span class="n">xydiff_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s12</span><span class="p">:</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1_interp</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">x2_interp</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">1</span><span class="p">]))),</span>
                                         <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z1_interp</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">z2_interp</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))</span>

            <span class="n">s12_intercept</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">ier</span><span class="p">,</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">xydiff_lambda</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">],</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#, factor=0.1,</span>
            <span class="n">xz1_intercept</span> <span class="o">=</span> <span class="n">x1_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">z1_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xz2_intercept</span> <span class="o">=</span> <span class="n">x2_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">z2_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pxz1_intercept</span> <span class="o">=</span> <span class="n">px1_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">pz1_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pxz2_intercept</span> <span class="o">=</span> <span class="n">px2_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">pz2_interp</span><span class="p">(</span><span class="n">s12_intercept</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1">#print(ier, mesg, s12_intercept, s12_intercept)</span>
            <span class="c1"># self.x1_interp = x1_interp</span>
            <span class="c1"># self.x2_interp = x2_interp</span>
            <span class="c1"># self.z1_interp = z1_interp</span>
            <span class="c1"># self.z2_interp = z2_interp</span>
            <span class="c1"># self.xydiff_lambda = xydiff_lambda</span>

            <span class="k">return</span> <span class="n">xz1_intercept</span><span class="p">,</span> <span class="n">xz2_intercept</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span>

        <span class="k">def</span> <span class="nf">eliminate_caustic</span><span class="p">(</span><span class="n">is_good_pt_array</span><span class="p">,</span> <span class="n">rpt_isochrone</span><span class="p">):</span>
            <span class="c1"># Locate and remove caustic and render into a cusp - if there is one</span>

            <span class="c1"># Check if there are any false points - if not, just return the whole curve</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">is_good_pt_array</span><span class="p">])</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">]):</span>
                <span class="c1">#print(&#39;whole curve&#39;)</span>
                <span class="k">return</span> <span class="n">rpt_isochrone</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Check if there are ONLY false points, in which case return an empty curve</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">is_good_pt_array</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(&#39;empty curve&#39;)</span>
                <span class="k">return</span> <span class="n">truncate_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Find false indexes</span>
            <span class="n">false_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_good_pt_array</span><span class="o">==</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># If false_indexes[0]==0, there&#39;s no left curve, so use only the right half</span>
            <span class="k">if</span> <span class="n">false_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(&#39;right half&#39;)</span>
                <span class="k">return</span> <span class="n">truncate_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">,</span><span class="n">false_indexes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_indexes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">last_false_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">false_indexes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">false_indexes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                                    <span class="k">if</span> <span class="n">fi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#print(&#39;last:&#39;, last_false_index)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_false_index</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">false_indexes</span> <span class="o">=</span> <span class="n">false_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">last_false_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

            <span class="c1"># Otherwise, generate interpolations of x and y points for both left and right curves</span>
            <span class="n">slice1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:(</span><span class="n">false_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">slice2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[(</span><span class="n">false_indexes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>

            <span class="c1"># If false_indexes[-1]==len(false_indexes)-1, use only left half (won&#39;t happen?)</span>
            <span class="c1">#   (assumes pattern is TTFFFFTT or TTTTFFFF etc)</span>
            <span class="k">if</span> <span class="n">false_indexes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">is_good_pt_array</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_good_pt_array</span><span class="p">[</span><span class="n">slice2</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1">#print(&#39;left half&#39;)</span>
                <span class="k">return</span> <span class="n">truncate_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">false_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># At this point, we presumably have a caustic, so find the cusp intercept</span>
            <span class="n">rxz1_intercept</span><span class="p">,</span> <span class="n">rxz2_intercept</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span> <span class="o">=</span> <span class="n">find_intercept</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">,</span> <span class="n">slice1</span><span class="p">,</span> <span class="n">slice2</span><span class="p">)</span>
            <span class="c1">#print(&#39;Intercept @ &#39;, rxz1_intercept,rxz2_intercept)</span>

            <span class="c1"># Delimit the portions to the left and to the right of the cusp</span>
            <span class="n">i1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">slice1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">rxz1_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i2_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">slice2</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">rxz1_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#print(&#39;i1,i2 arrays&#39;, i1_array,i2_array)</span>

            <span class="c1"># Rebuild the isochrone dictionary</span>
            <span class="n">rpt_isochrone_rtn</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                <span class="n">isochrone_left</span>  <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">slice1</span><span class="p">]</span>
                <span class="n">isochrone_right</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">slice2</span><span class="p">]</span>
                <span class="n">isochrone_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">isochrone_left</span><span class="p">[</span><span class="n">i1_array</span><span class="p">],</span><span class="n">isochrone_right</span><span class="p">[</span><span class="n">i2_array</span><span class="p">]])</span>
                <span class="n">rpt_isochrone_rtn</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">rp_</span><span class="p">:</span> <span class="n">isochrone_</span><span class="p">})</span>
            <span class="n">rpt_isochrone_rtn</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;t&#39;</span><span class="p">:</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]})</span>

            <span class="k">return</span> <span class="n">rpt_isochrone_rtn</span><span class="p">,</span> \
                <span class="p">((</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rxz1_intercept</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pxz1_intercept</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pxz2_intercept</span><span class="p">))</span> \
                    <span class="k">if</span> <span class="n">rxz1_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dont_crop_cusps</span> <span class="ow">or</span> <span class="n">rxz1_intercept</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">x_1</span><span class="p">])</span> \
                            <span class="k">else</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">compose_isochrone</span><span class="p">(</span><span class="n">i_isochrone</span><span class="p">,</span> <span class="n">t_</span><span class="p">):</span>
            <span class="c1"># Prepare a tmp dictionary for the rx,rz,px,pz component arrays delineating this isochrone</span>
            <span class="n">rpt_isochrone</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                <span class="c1"># Sample each ray at time t_ from each of the components of r,p vectors using their interpolating fns</span>
                <span class="n">rp_interpolated_isochrone</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">interp_fn</span><span class="p">(</span><span class="n">t_</span><span class="p">))</span> <span class="k">for</span> <span class="n">interp_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rp_t_interp_fns</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span>
                                            <span class="k">if</span> <span class="n">interp_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">rpt_isochrone</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="n">rp_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rp_interpolated_isochrone</span><span class="p">)}</span> <span class="p">)</span>
            <span class="n">rpt_isochrone</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;t&#39;</span><span class="p">:</span><span class="n">t_</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">rpt_isochrone</span>

        <span class="k">def</span> <span class="nf">resample_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone_in</span><span class="p">):</span>
            <span class="n">n_s_pts</span> <span class="o">=</span> <span class="mi">301</span>
            <span class="n">rpt_isochrone_out</span> <span class="o">=</span> <span class="n">rpt_isochrone_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">s_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">rpt_isochrone_in</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">rpt_isochrone_in</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                                                             <span class="o">+</span> <span class="p">(</span><span class="n">rpt_isochrone_in</span><span class="p">[</span><span class="s1">&#39;rz&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">rpt_isochrone_in</span><span class="p">[</span><span class="s1">&#39;rz&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span> <span class="p">)</span>
            <span class="n">rs_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">s_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">num</span><span class="o">=</span><span class="n">n_s_pts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span> <span class="k">return</span> <span class="n">rpt_isochrone_out</span>    <span class="c1"># HACK to avoid interpolating a crap isochrone sampled only at one point</span>
            <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                <span class="n">rpt_isochrone_interp_fn</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">s_array</span><span class="p">,</span> <span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="n">rp_</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                                  <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_isochrone_interp_fn</span><span class="p">(</span><span class="n">rs_array</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rpt_isochrone_out</span>

        <span class="c1"># Crop out-of-bounds points and points on caustics for the current isochrone</span>

        <span class="k">def</span> <span class="nf">clean_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">):</span>
            <span class="c1"># Cusps: eliminate all points beyond the first whose rx sequence is negative (left-ward)</span>
            <span class="c1">#   - do this by creating a flag array whose elements are True if rx[i+1]&gt;rx[i]</span>
            <span class="n">is_good_pt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(((</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=-</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">),[</span><span class="kc">True</span><span class="p">]))</span>

            <span class="c1"># Replace this isochrone with one whose caustic has been removed - if it has one</span>
            <span class="c1"># rpt_isochrone_try, (t_rxz_intercept, pxz1_intercept, pxz2_intercept) \</span>
            <span class="c1">#         = eliminate_caustic(is_good_pt_array, rpt_isochrone) if do_eliminate_caustics else None, (None,None,None)</span>
            <span class="k">if</span> <span class="n">do_eliminate_caustics</span><span class="p">:</span>
                <span class="n">rpt_isochrone</span><span class="p">,</span> <span class="p">(</span><span class="n">t_rxz_intercept</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">)</span> \
                        <span class="o">=</span> <span class="n">eliminate_caustic</span><span class="p">(</span><span class="n">is_good_pt_array</span><span class="p">,</span> <span class="n">rpt_isochrone</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rpt_isochrone</span><span class="p">,</span> <span class="p">(</span><span class="n">t_rxz_intercept</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># print(rpt_isochrone_try)</span>
            <span class="c1"># rpt_isochrone = rpt_isochrone_try if rpt_isochrone_try is not None else rpt_isochrone</span>
            <span class="k">return</span> <span class="n">rpt_isochrone</span><span class="p">,</span> <span class="p">(</span><span class="n">t_rxz_intercept</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">prune_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone_in</span><span class="p">):</span>
            <span class="n">rpt_isochrone_out</span> <span class="o">=</span> <span class="n">rpt_isochrone_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">rx_array</span> <span class="o">=</span> <span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">]</span>
            <span class="n">i_bounded_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_array</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rx_array</span><span class="o">&lt;=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx_array</span><span class="p">[</span><span class="n">i_bounded_array</span><span class="p">]</span>
            <span class="n">did_clip_at_x1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rx_array</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                <span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_isochrone_in</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">i_bounded_array</span><span class="p">]</span>
                <span class="c1"># Wildly inefficient interpolation to do extrapolation here</span>
                <span class="k">if</span> <span class="n">did_clip_at_x1</span><span class="p">:</span>
                    <span class="n">rpt_isochrone_interp_fn</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">rx_array</span><span class="p">[</span><span class="n">rx_array</span><span class="o">&gt;=</span><span class="mf">0.95</span><span class="p">],</span> <span class="n">rpt_isochrone_in</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">rx_array</span><span class="o">&gt;=</span><span class="mf">0.95</span><span class="p">],</span>
                                                      <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">rpt_at_x1</span> <span class="o">=</span> <span class="n">rpt_isochrone_interp_fn</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                    <span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="n">rp_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">rpt_isochrone_out</span><span class="p">[</span><span class="n">rp_</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rpt_at_x1</span><span class="p">])])</span>
            <span class="k">return</span> <span class="n">rpt_isochrone_out</span>

        <span class="k">def</span> <span class="nf">record_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">):</span>
            <span class="c1"># Record this isochrone</span>
            <span class="k">for</span> <span class="n">rpt_</span> <span class="ow">in</span> <span class="n">rpt_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rpt_isochrones</span><span class="p">[</span><span class="n">rpt_</span><span class="p">][</span><span class="n">i_isochrone</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="n">rpt_</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">record_cusp</span><span class="p">(</span><span class="n">trxz_cusp</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">trxz_cusp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Record this intercept</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trxz_cusps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">trxz_cusp</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">organize_cusps</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cusps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cusps</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">t_</span>    <span class="k">for</span> <span class="p">(</span><span class="n">t_</span><span class="p">,</span><span class="n">rxz_</span><span class="p">),</span><span class="n">pxz1_</span><span class="p">,</span><span class="n">pxz2_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trxz_cusps</span> <span class="k">if</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cusps</span><span class="p">[</span><span class="s1">&#39;rxz&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">rxz_</span>  <span class="k">for</span> <span class="p">(</span><span class="n">t_</span><span class="p">,</span><span class="n">rxz_</span><span class="p">),</span><span class="n">pxz1_</span><span class="p">,</span><span class="n">pxz2_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trxz_cusps</span> <span class="k">if</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cusps</span><span class="p">[</span><span class="s1">&#39;pxz1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">pxz1_</span> <span class="k">for</span> <span class="p">(</span><span class="n">t_</span><span class="p">,</span><span class="n">rxz_</span><span class="p">),</span><span class="n">pxz1_</span><span class="p">,</span><span class="n">pxz2_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trxz_cusps</span> <span class="k">if</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cusps</span><span class="p">[</span><span class="s1">&#39;pxz2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">pxz2_</span> <span class="k">for</span> <span class="p">(</span><span class="n">t_</span><span class="p">,</span><span class="n">rxz_</span><span class="p">),</span><span class="n">pxz1_</span><span class="p">,</span><span class="n">pxz2_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trxz_cusps</span> <span class="k">if</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">rxz_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">coarsen_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">):</span>
            <span class="c1"># Reduce the time resolution of the isochrone points to make plotting less cluttered</span>
            <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="n">rp_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rpt_isochrones_lowres</span><span class="p">[</span><span class="n">rp_</span><span class="p">][</span><span class="n">i_isochrone</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">element_</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">element_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array_</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span><span class="o">//</span><span class="n">x_subset</span><span class="o">-</span><span class="n">idx</span><span class="o">/</span><span class="n">x_subset</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">array_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">rpt_isochrone</span><span class="p">[</span><span class="n">rp_</span><span class="p">]]</span> <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rpt_isochrones_lowres</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="n">i_isochrone</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_isochrone</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>

        <span class="c1"># Time sequence - with resolution n_isochrones and limit t_isochrone_max</span>

        <span class="n">prepare_isochrones</span><span class="p">()</span>
        <span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">t_isochrone_max</span><span class="p">,</span><span class="n">n_isochrones</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_isochrone</span><span class="p">,</span><span class="n">t_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_array</span><span class="p">):</span>
            <span class="n">rpt_isochrone</span> <span class="o">=</span> <span class="n">compose_isochrone</span><span class="p">(</span><span class="n">i_isochrone</span><span class="p">,</span> <span class="n">t_</span><span class="p">)</span>
            <span class="n">rpt_isochrone</span> <span class="o">=</span> <span class="n">resample_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">)</span>
            <span class="n">rpt_isochrone</span><span class="p">,</span> <span class="p">(</span><span class="n">trxz_cusp</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">)</span> <span class="o">=</span> <span class="n">clean_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rpt_isochrone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rpt_isochrone</span> <span class="o">=</span> <span class="n">prune_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">)</span>
                <span class="n">record_isochrone</span><span class="p">(</span><span class="n">rpt_isochrone</span><span class="p">)</span>
                <span class="n">record_cusp</span><span class="p">(</span><span class="n">trxz_cusp</span><span class="p">,</span> <span class="n">pxz1_intercept</span><span class="p">,</span> <span class="n">pxz2_intercept</span><span class="p">)</span>
        <span class="n">organize_cusps</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">measure_cusp_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs_</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cusps</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cx_pz_tanbeta_lambda</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cx_pz_lambda</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cx_v_lambda</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx_interp_fast</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx_interp_slow</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="n">t_fast_array</span><span class="p">,</span> <span class="n">rxz_array</span><span class="p">,</span> <span class="n">pxz_fast_array</span><span class="p">,</span> <span class="n">pxz_slow_array</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cusps</span><span class="p">[</span><span class="n">key_</span><span class="p">]</span> \
                                                                    <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span><span class="s1">&#39;rxz&#39;</span><span class="p">,</span><span class="s1">&#39;pxz1&#39;</span><span class="p">,</span><span class="s1">&#39;pxz2&#39;</span><span class="p">]]</span>
        <span class="n">px_fast_array</span><span class="p">,</span> <span class="n">pz_fast_array</span> <span class="o">=</span> <span class="n">pxz_fast_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pxz_fast_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">px_slow_array</span><span class="p">,</span> <span class="n">pz_slow_array</span> <span class="o">=</span> <span class="n">pxz_slow_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pxz_slow_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rx_array</span><span class="p">,</span> <span class="n">rz_array</span> <span class="o">=</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">p_fast_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">px_fast_array</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">pz_fast_array</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tanbeta_fast_array</span> <span class="o">=</span> <span class="o">-</span><span class="n">px_fast_array</span><span class="o">/</span><span class="n">pz_fast_array</span>
        <span class="n">sinbeta_fast_array</span> <span class="o">=</span>  <span class="n">px_fast_array</span><span class="o">/</span><span class="n">p_fast_array</span>
        <span class="n">cosbeta_fast_array</span> <span class="o">=</span> <span class="o">-</span><span class="n">pz_fast_array</span><span class="o">/</span><span class="n">p_fast_array</span>
        <span class="n">p_fast_interp</span>       <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fast_array</span><span class="p">,</span>       <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">px_fast_interp</span>      <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">px_fast_array</span><span class="p">,</span>      <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">pz_fast_interp</span>      <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pz_fast_array</span><span class="p">,</span>      <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">tanbeta_fast_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">tanbeta_fast_array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">sinbeta_fast_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">sinbeta_fast_array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">cosbeta_fast_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cosbeta_fast_array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>

        <span class="n">p_slow_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">px_slow_array</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">pz_slow_array</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tanbeta_slow_array</span> <span class="o">=</span> <span class="o">-</span><span class="n">px_slow_array</span><span class="o">/</span><span class="n">pz_slow_array</span>
        <span class="n">sinbeta_slow_array</span> <span class="o">=</span>  <span class="n">px_slow_array</span><span class="o">/</span><span class="n">p_slow_array</span>
        <span class="n">cosbeta_slow_array</span> <span class="o">=</span> <span class="o">-</span><span class="n">pz_slow_array</span><span class="o">/</span><span class="n">p_slow_array</span>
        <span class="n">p_slow_interp</span>       <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_slow_array</span><span class="p">,</span>       <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">px_slow_interp</span>      <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">px_slow_array</span><span class="p">,</span>      <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">pz_slow_interp</span>      <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pz_slow_array</span><span class="p">,</span>      <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">tanbeta_slow_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">tanbeta_slow_array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">sinbeta_slow_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">sinbeta_slow_array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">cosbeta_slow_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rxz_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cosbeta_slow_array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>

        <span class="c1"># Provide a lambda fn that returns the horizontal cusp velocity component cx</span>
        <span class="c1">#   using interpolation functions for all the variables for which we have sampled solutions as arrays</span>
        <span class="c1"># sinbeta_diff_lambda = lambda x_: sinbeta_fast_interp(x_)*cosbeta_slow_interp(x_) \</span>
        <span class="c1">#                                 - cosbeta_fast_interp(x_)*sinbeta_slow_interp(x_)</span>
        <span class="c1"># tanbeta_diff_lambda = lambda x_: tanbeta_fast_interp(x_) - tanbeta_slow_interp(x_)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cx_pz_tanbeta_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x_</span><span class="p">:</span> <span class="p">(</span>
            <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">pz_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">pz_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">tanbeta_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="n">tanbeta_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cx_pz_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x_</span><span class="p">:</span> <span class="p">(</span>
                                <span class="p">(</span> <span class="n">pz_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="n">pz_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">px_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">*</span><span class="n">pz_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="n">pz_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">*</span><span class="n">px_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">rpdot_fast_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">model_dXdt_lambda</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rp_</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rx_array</span><span class="p">,</span><span class="n">rz_array</span><span class="p">,</span><span class="n">px_fast_array</span><span class="p">,</span><span class="n">pz_fast_array</span><span class="p">)])</span>
        <span class="n">rpdot_slow_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">model_dXdt_lambda</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rp_</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">rp_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rx_array</span><span class="p">,</span><span class="n">rz_array</span><span class="p">,</span><span class="n">px_slow_array</span><span class="p">,</span><span class="n">pz_slow_array</span><span class="p">)])</span>
        <span class="n">vx_interp_fast</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rx_array</span><span class="p">,</span> <span class="n">rpdot_fast_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">vx_interp_slow</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rx_array</span><span class="p">,</span> <span class="n">rpdot_slow_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">vz_interp_fast</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rx_array</span><span class="p">,</span> <span class="n">rpdot_fast_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="n">vz_interp_slow</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span> <span class="n">rx_array</span><span class="p">,</span> <span class="n">rpdot_slow_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs_</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cx_v_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x_</span><span class="p">:</span> <span class="p">(</span>
            <span class="p">(</span> <span class="p">(</span><span class="n">tanbeta_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">*</span><span class="n">vx_interp_fast</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="n">vz_interp_fast</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">tanbeta_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span><span class="o">*</span><span class="n">vx_interp_slow</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="n">vz_interp_slow</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span> <span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">tanbeta_fast_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">-</span> <span class="n">tanbeta_slow_interp</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx_interp_fast</span> <span class="o">=</span> <span class="n">vx_interp_fast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx_interp_slow</span> <span class="o">=</span> <span class="n">vx_interp_slow</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rpt_arrays</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">rpt_</span> <span class="ow">in</span> <span class="n">rpt_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="p">[</span><span class="n">rpt_</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_arrays</span><span class="p">[</span><span class="n">rpt_</span><span class="p">]</span>
        <span class="n">rx_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="p">[</span><span class="s1">&#39;rx&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpt_arrays</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][:</span><span class="n">rx_length</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">report_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">progress_was</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pc_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">is_initial_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">progress_now</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="mi">100</span><span class="o">/</span><span class="n">pc_step</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">100</span><span class="o">/</span><span class="n">pc_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">progress_now</span><span class="o">&gt;</span><span class="n">progress_was</span> <span class="ow">or</span> <span class="n">is_initial_step</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:0.0f}</span><span class="s1">% &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">progress_now</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">progress_now</span><span class="o">&lt;</span><span class="mi">100</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">progress_now</span>





<span class="c1">#</span>
</pre></div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
    <a id="sidebar-anchor"></a>
    

<div id="searchbox" style="display: none" role="search">
    <a class="biglink" href="../index.html">
        <img src="../_static/gme_icon.png" />
    </a>
  <h3></h3>
    <form class="search" action="../search.html" method="get">
      <div class="ui action left icon input">
        <i class="search icon"></i>
        <input type="text" name="q" placeholder="Search...">
        <div class="ui teal button"></div>
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<!-- <br> -->
<script type="text/javascript">$('#searchbox').show(0);</script>
    <!-- <h3><a href="../index.html">This page</a></h3> -->
    <!-- <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ode_base.py</span></code></a><ul>
<li><a class="reference internal" href="#code">Code</a></li>
</ul>
</li>
</ul>
 -->
    <!-- <p class="biglink"> -->
        <h3><a href="../genindex.html"> Index</a></h3>
    <!-- </p> -->
  <!-- <br> -->
  <!-- <p class="biglink"><a class="biglink" href="../py-modindex.html">
         Module index</a>
  <br><br> --><h3><a href="../index.html">Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Design.html">  Software design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependencies.html">  Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="Installation.html">  Installation and set-up</a></li>
<li class="toctree-l1"><a class="reference internal" href="Running.html">  Running the notebooks</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Python.html">  Python package docs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="symbols.html"> Symbol definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations.html"> Equation derivations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"> ODE integration (base)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ode_raytracing.html"> ODE integration (ray tracing)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ode_knickpoints.html"> ODE integration (knickpoints)</a></li>
<li class="toctree-l2"><a class="reference internal" href="plot.html"> Plotting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Notebooks.html">  Notebook docs</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ode_raytracing.html" title="ode_raytracing.py"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="equations.html" title="equations.py"
             accesskey="P">previous</a> |</li>
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, CPS.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.3.
    </div>
  </body>
</html>